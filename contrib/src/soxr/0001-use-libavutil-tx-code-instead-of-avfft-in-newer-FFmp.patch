From d950ec16ad02c11b1fe41d9e873311a2b2b35d2f Mon Sep 17 00:00:00 2001
From: Steve Lhomme <robux4@ycbcr.xyz>
Date: Fri, 7 Nov 2025 14:38:39 +0100
Subject: [PATCH] use libavutil tx code instead of avfft in newer FFmpeg

The code is using the replacement code from libavcodec 7.1 using the tx API.
---
 src/avfft32.c  | 112 +++++++++++++++++++++++++++++++++++++++++++++++++
 src/avfft32s.c | 112 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 224 insertions(+)

diff --git a/src/avfft32.c b/src/avfft32.c
index fe651f5..409b478 100644
--- a/src/avfft32.c
+++ b/src/avfft32.c
@@ -3,13 +3,121 @@
 
 #include <stdlib.h>
 #include <math.h>
+#include <libavutil/version.h>
+#define USE_LAVUTIL_TX  (LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(57,19,100))
+#if USE_LAVUTIL_TX
+# include <libavutil/tx.h>
+# include <string.h>
+# include <stdlib.h>
+
+typedef struct AVTXWrapper {
+    AVTXContext *ctx;
+    av_tx_fn fn;
+
+    ptrdiff_t stride;
+    int len;
+    int inv;
+
+    float *tmp;
+} AVTXWrapper;
+#else /* !USE_LAVUTIL_TX */
 #include <libavcodec/avfft.h>
+#endif /* !USE_LAVUTIL_TX */
 #include "filter.h"
 #include "rdft_t.h"
 
+#if USE_LAVUTIL_TX
+static void * forward_setup(int len) {
+    int ret;
+    float scale = (0) ? 0.5f : 1.0f;
+    AVTXWrapper *s;
+
+    s = malloc(sizeof(*s));
+    if (!s)
+        return NULL;
+
+    s->stride = (0) ? sizeof(AVComplexFloat) : sizeof(float);
+    s->len = 1 << (int)(log(len)/log(2)+.5);
+    s->inv = (0);
+
+    ret = av_tx_init(&s->ctx, &s->fn, AV_TX_FLOAT_RDFT, (0),
+                     s->len, &scale, 0x0);
+    if (ret < 0) {
+        free(s);
+        return NULL;
+    }
+
+    s->tmp = malloc((s->len + 2)*sizeof(float));
+    if (!s->tmp) {
+        av_tx_uninit(&s->ctx);
+        free(s);
+        return NULL;
+    }
+
+    return s;
+}
+static void * backward_setup(int len) {
+    int ret;
+    float scale = (1) ? 0.5f : 1.0f;
+    AVTXWrapper *s;
+
+    s = malloc(sizeof(*s));
+    if (!s)
+        return NULL;
+
+    s->stride = (1) ? sizeof(AVComplexFloat) : sizeof(float);
+    s->len = 1 << (int)(log(len)/log(2)+.5);
+    s->inv = (1);
+
+    ret = av_tx_init(&s->ctx, &s->fn, AV_TX_FLOAT_RDFT, (1),
+                     s->len, &scale, 0x0);
+    if (ret < 0) {
+        free(s);
+        return NULL;
+    }
+
+    s->tmp = malloc((s->len + 2)*sizeof(float));
+    if (!s->tmp) {
+        av_tx_uninit(&s->ctx);
+        free(s);
+        return NULL;
+    }
+
+    return s;
+}
+static void rdft(int length, void * setup, float * data) {
+    AVTXWrapper *w = setup;
+    float *src = w->inv ? w->tmp : data;
+    float *dst = w->inv ? data : w->tmp;
+
+    if (w->inv) {
+        memcpy(src, data, w->len*sizeof(float));
+
+        src[w->len] = src[1];
+        src[1] = 0.0f;
+    }
+
+    w->fn(w->ctx, dst, (void *)src, w->stride);
+
+    if (!w->inv) {
+        dst[1] = dst[w->len];
+        memcpy(data, dst, w->len*sizeof(float));
+    }
+    (void)length;
+}
+static void rdft_end(AVTXWrapper *s)
+{
+    if (s) {
+        av_tx_uninit(&s->ctx);
+        free(s->tmp);
+        free(s);
+    }
+}
+#else
 static void * forward_setup(int len) {return av_rdft_init((int)(log(len)/log(2)+.5),DFT_R2C);}
 static void * backward_setup(int len) {return av_rdft_init((int)(log(len)/log(2)+.5),IDFT_C2R);}
 static void rdft(int length, void * setup, float * h) {av_rdft_calc(setup, h); (void)length;}
+#endif
 static int multiplier(void) {return 2;}
 static void nothing(void) {}
 static int flags(void) {return 0;}
@@ -17,7 +125,11 @@ static int flags(void) {return 0;}
 fn_t _soxr_rdft32_cb[] = {
   (fn_t)forward_setup,
   (fn_t)backward_setup,
+#if USE_LAVUTIL_TX
+  (fn_t)rdft_end,
+#else
   (fn_t)av_rdft_end,
+#endif
   (fn_t)rdft,
   (fn_t)rdft,
   (fn_t)rdft,
diff --git a/src/avfft32s.c b/src/avfft32s.c
index 5a7e62d..9ffbe47 100644
--- a/src/avfft32s.c
+++ b/src/avfft32s.c
@@ -2,13 +2,121 @@
  * Licence for this file: LGPL v2.1                  See LICENCE for details. */
 
 #include <math.h>
+#include <libavutil/version.h>
+#define USE_LAVUTIL_TX  (LIBAVUTIL_VERSION_INT >= AV_VERSION_INT(57,19,100))
+#if USE_LAVUTIL_TX
+# include <libavutil/tx.h>
+# include <string.h>
+# include <stdlib.h>
+
+typedef struct AVTXWrapper {
+    AVTXContext *ctx;
+    av_tx_fn fn;
+
+    ptrdiff_t stride;
+    int len;
+    int inv;
+
+    float *tmp;
+} AVTXWrapper;
+#else /* !USE_LAVUTIL_TX */
 #include <libavcodec/avfft.h>
+#endif /* !USE_LAVUTIL_TX */
 #include "util32s.h"
 #include "rdft_t.h"
 
+#if USE_LAVUTIL_TX
+static void * forward_setup(int len) {
+    int ret;
+    float scale = (0) ? 0.5f : 1.0f;
+    AVTXWrapper *s;
+
+    s = malloc(sizeof(*s));
+    if (!s)
+        return NULL;
+
+    s->stride = (0) ? sizeof(AVComplexFloat) : sizeof(float);
+    s->len = 1 << (int)(log(len)/log(2)+.5);
+    s->inv = (0);
+
+    ret = av_tx_init(&s->ctx, &s->fn, AV_TX_FLOAT_RDFT, (0),
+                     s->len, &scale, 0x0);
+    if (ret < 0) {
+        free(s);
+        return NULL;
+    }
+
+    s->tmp = malloc((s->len + 2)*sizeof(float));
+    if (!s->tmp) {
+        av_tx_uninit(&s->ctx);
+        free(s);
+        return NULL;
+    }
+
+    return s;
+}
+static void * backward_setup(int len) {
+    int ret;
+    float scale = (1) ? 0.5f : 1.0f;
+    AVTXWrapper *s;
+
+    s = malloc(sizeof(*s));
+    if (!s)
+        return NULL;
+
+    s->stride = (1) ? sizeof(AVComplexFloat) : sizeof(float);
+    s->len = 1 << (int)(log(len)/log(2)+.5);
+    s->inv = (1);
+
+    ret = av_tx_init(&s->ctx, &s->fn, AV_TX_FLOAT_RDFT, (1),
+                     s->len, &scale, 0x0);
+    if (ret < 0) {
+        free(s);
+        return NULL;
+    }
+
+    s->tmp = malloc((s->len + 2)*sizeof(float));
+    if (!s->tmp) {
+        av_tx_uninit(&s->ctx);
+        free(s);
+        return NULL;
+    }
+
+    return s;
+}
+static void rdft(int length, void * setup, float * data) {
+    AVTXWrapper *w = setup;
+    float *src = w->inv ? w->tmp : data;
+    float *dst = w->inv ? data : w->tmp;
+
+    if (w->inv) {
+        memcpy(src, data, w->len*sizeof(float));
+
+        src[w->len] = src[1];
+        src[1] = 0.0f;
+    }
+
+    w->fn(w->ctx, dst, (void *)src, w->stride);
+
+    if (!w->inv) {
+        dst[1] = dst[w->len];
+        memcpy(data, dst, w->len*sizeof(float));
+    }
+    (void)length;
+}
+static void rdft_end(AVTXWrapper *s)
+{
+    if (s) {
+        av_tx_uninit(&s->ctx);
+        free(s->tmp);
+        free(s);
+    }
+}
+#else
 static void * forward_setup(int len) {return av_rdft_init((int)(log(len)/log(2)+.5),DFT_R2C);}
 static void * backward_setup(int len) {return av_rdft_init((int)(log(len)/log(2)+.5),IDFT_C2R);}
 static void rdft(int length, void * setup, float * h) {av_rdft_calc(setup, h); (void)length;}
+#endif
 static int multiplier(void) {return 2;}
 static void nothing(void) {}
 static int flags(void) {return RDFT_IS_SIMD;}
@@ -16,7 +124,11 @@ static int flags(void) {return RDFT_IS_SIMD;}
 fn_t _soxr_rdft32s_cb[] = {
   (fn_t)forward_setup,
   (fn_t)backward_setup,
+#if USE_LAVUTIL_TX
+  (fn_t)rdft_end,
+#else
   (fn_t)av_rdft_end,
+#endif
   (fn_t)rdft,
   (fn_t)rdft,
   (fn_t)rdft,
-- 
2.45.1.windows.1

